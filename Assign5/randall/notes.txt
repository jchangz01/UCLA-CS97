Steps taken to optimize randall.c
1. Create a new target called 'check' in Makefile with executable randall
	and test.sh as pre-requisites. This target should execute
	a file called test.sh that runs tests on your randall file.
	check: randall test.sh

2. Implement a simple test.sh that checks if the output of randall
	is the correct number of generated bytes

3. Understand the code inside randall.c and the content of Makefile

4. Split randall.c into the following modules:
	- options.c with header options.h, which does command-line options processing.
		Initially there isn't very much of this.
	- output.c with header output.h, which does the output.
	- rand64-hw.c with header rand64-hw.h, does the hardware-based rand-number generation
	- rand64-sw.c with header rand64-sw.h, does the software-based rand-number generation
	- randall.c should contain the main program that glues together everything
		else. It should include the .h files mentioned above, 
		and use their APIs to do its work.

5. When splitting randall.c into different modules, REMEMBER to remove 'static' keyword
	from function definitions so that they are not limited to their object file!

6. Remember to also include the proper header files (INCLUDE ONLY what is required for
	the file)

7. When finished splitting randall.c, make sure to alter your Makefile, so that you
	are compiling all the files you've just created

8. If not yet done from step 4, remove the section bounded by comments 
	/* Check arguments */ to /* If there's no work to do . . . */
	to options.c.

9. In options.c, create a fuction called bool checkOptions(int argc, char* argv[], 
	struct options opts) that will process options and return true or false
	based on whether CLI are valid.

10. From step 9, you may notice a struct options. We will declare struct options
	in options.h and give it properties 
	- long long nbytes
	- char* input
	- char* input_file
	- char* output 
	- unsigned int block_size

11. We will create this to add two new options to our program. The two new options 
	will be:
		-i rdrand (default) | mrand | /FILE
		-o stdio (default) | N (unsigned int)
	^ with respective possible arguments seperated by '|'

12. Process these options in options.c using getopt from #include <unistd.h>
	Remember to print errors using fprintf(stderr, "..."); and
	exit with status 1 when options or operands are invalid.

13. Make changes to our hardware and software implementations based on the
	option arguments added.

14. The first input option argument will be the default and current random 
	byte generator (rdrand). rdrand is only supported by x86-64, so when
	invoked with -i and the machine executing the program is not x86-64, 
	we display an error message to stderr and exit with 1. Besides this,
	original implementation should suffice.

15. The second input option argument is mrand48_r from the GNU C Library. We 
	will add our implementation of mrand48_r in our rand64-sw.c file. 
	Three functions: void mrand48_rng_init (void), unsigned long long
	mrand48_rng (void), and void mrand48_rng_fini will be created. In addition, 
	we will declare a struct drand48_data buf = {0} in our files global scope.
	Inside our ini function, we will call srand48_r(time(NULL), &buf) to
	randomize our buf. Inside our base function we will have the impl as follows:


	unsigned unsigned long mrand48_rng (void) {
		long int x;
		long int y;
		mrand48_r (&buf, &x);
		mrand48_r (&buf, &y);
	
		return ((unsigned long long)x << 32) |
			((unsigned long long)y & 0x00000000FFFFFFFF);
	}

	Finally, our fini function will be empty. REMEMBER to alter rand64-sw.h, 
	accordingly and #include<time.h> in our rand64-sw.c file.


16. The third input option argument is /FILE where FILE is the path to a file in
	our local system. Like the step before, we will edit rand64-sw.c. In particular,
	we will add a parameter to the sw init function of type char * called file. We will 
	edit this function to open the file when specified or default back to 
	/dev/random. Alter randall.c, so that we create a function pointer initialize-sw
	that takes a char* as an argument and set this to the sw implementation when
	a /FILE is specified.

17. The first output option argument is the default output. Not much should be changed. 


18. The second output option argument is the "N" option where N is the number of kibi
	bytes outputed at a time using write. We accomplish this by writing a function 
	in output.c called writeByteChunks(char* buf, int output_size) which simply
	calls write (1, buf, output_size) a.k.a. write output_size number of bytes in
	the contents of buf to stdout. In randall.c, we will invoke this function by
	creating an if/else between the standard stdio impl and N KiB impl. It will 
	look like as follows:

	if (strcmp(opts.output, "N") == 0)
	{
		unsigned int output_blockSize = opts.block_size * 1024;
		unsigned long long x;
		char* byte_buffer = (char*)malloc(output_blockSize);
		if (byte_buffer == NULL) {
			fprintf(stderr, "TERMINATE! Accessed NULL memory!!\n");
			exit(1);
		}
		
		while (nbytes > 0){
			unsigned int output_size = nbytes < output_blockSize ?
							 nbytes : output_blockSize;
			for (unsigned int i = 0; i < output_size; i++) {
				if (i % 8 == 0)
					x = rand64();
				byte_buffer[i] = x >> (i % 8);
			}
			writebyteChunks (byte_buffer, output_size);
			nbytes -= output_size;
		}
		free(byte_buffer);
	}
	else { stdio impl ... }
 
19. With all the features implemented, it is now time to test! Add some extra
	test cases to make check.


Testing Results
time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null
	Real-time: 0.68s

time ./randall 133562368 >/dev/null
time ./randall 133562368 | cat >/dev/null
time ./randall 133562368 >rand.data	
	My randall.c impl was not able to process these numbers in a 
	timely manner (12min+ Real-runtime), so I adjusted byte count values
	to two less digits

time ./randall 1335623 >/dev/null
	Real-time: 9min 50s
time ./randall 1335623 | cat >/dev/null
	Real-time: 10min 08s
time ./randall 1335623 >rand.data	
 	Real-time: 9min 45s
	
	At an attempt to further reduce times w/o reducing byte count, I set
	the gcc optimization to -O and -O2 and retest the test above.

time ./randall 1335623 >/dev/null
	-O Real-time: 
	-O2 Real-time:
	
	Because these times were roughly the same as default optimization, I
	decided to only test the first of the 3 given test cases. Also, I 
	left the optimization at -O for the remaining tests. 

	We will proceed by observing how our options increase or decrease
	run time. Starting with -i mrand48_r

time ./randall -i mrand48_r 133562368 >/dev/null	
	Real-time: 1.51s
time ./randall -i mrand48_r 133562368 | cat >/dev/null	
	Real-time: 1.6s
time ./randall -i mrand48_r 133562368 >rand.data
	Real-time: 2.74s

	As we can see, the test results are MUCH faster with this input option.
	We will now test the -i /FILE option using the the file /dev/urandom


time ./randall -i /dev/urandom 133562368 >/dev/null	
	Real-time: 2.37s
time ./randall -i /dev/urandom 133562368 | cat >/dev/null	
	Real-time: 2.54s
time ./randall -i /dev/urandom 133562368 >rand.data
	Real-time: 4.39s

	Generating random bytes using the file dev/urandom seems to slightly 
	slower than using mrand48_r; however, it is significantly faster than
	using the file /dev/random.
	We will now proceed to test the -o N output KiB chunks at a time option.
	NOTE! We will not be testing the rdrand hw impl because we are running
	our program on a non x86-64 machine.

time ./randall -o 100 133562368 >/dev/null
	Real-time: Over 7 min

	Because this took too long, I decided to test with fewer digits for
	byte count.

time ./randall -o 10 133562 >/dev/null
	Real-time: 56.65s
time ./randall -o 10 133562 | cat >/dev/null
	Real-time: 57.82s
time ./randall -o 10 133562 >rand.data 
	Real-time: 58.9s

	Now that we have tested -o N alone, we will test it along with the
	-i option.

time ./randall -i mrand48_r -o 100 133562368 >/dev/null	
	Real-time: 0.48s
time ./randall -i mrand48_r -o 100 133562368 | cat >/dev/null	
	Real-time: 0.55s
time ./randall -i mrand48_r -o 100 133562368 >rand.data
	Real-time: 1.76s

time ./randall -i /dev/urandom -o 100 133562368 >/dev/null	
	Real-time: 1.25s
time ./randall -i /dev/urandom -o 100 133562368 | cat >/dev/null	
	Real-time: 1.45s
time ./randall -i /dev/urandom -o 100 133562368 >rand.data
	Real-time: 2.62s


	Check block_size = 1, 10, and 1000
	Results of these varying values of N do not heavily affect the run
	time in comparison to -o 100. Real-times only differ by at most 0.5s


From our results above, using the -i mrand48_ input option along 
with the -o N output option seems to generate a large number of bytes the fastest.

We will test this with a smaller number of bytes

time ./randall -i mrand48_r -o 1 10000 >rand.data 
	Real-time: 0.003s

^ MUCH FASTER THEN NO OPTIONS

time ./randall 10000 >rand.data
	Real-time: 4s
